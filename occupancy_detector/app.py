# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n57OR65Rm6okbHqojKmrDzpRwy3NAE-J
"""

import streamlit as st
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px
from sklearn.metrics import confusion_matrix, roc_curve, auc, accuracy_score, precision_score, recall_score
import joblib


st.set_page_config(page_title="Occupancy Detection Dashboard", layout="wide")
st.title("üè† Occupancy Detection Dashboard")

# Load model
@st.cache_resource
def load_model():
    return joblib.load("models/occupancy_final_model.pkl")  # replace with your model file

model = load_model()

# File Upload
data_file = st.sidebar.file_uploader("Upload CSV", type=["csv"])

if data_file:
    df = pd.read_csv(data_file)
    st.subheader("üìä Uploaded Data Preview")
    st.dataframe(df.head())

    # Time Series Plot
    if "Date" in df.columns:
        df['Date'] = pd.to_datetime(df['Date'])
        fig_ts = px.line(df, x='Date', y='Occupancy', title="Occupancy Over Time")
        st.plotly_chart(fig_ts)

    # Correlation Heatmap
    st.subheader("üîç Sensor Data Correlation")
    plt.figure(figsize=(8,6))
    sns.heatmap(df.corr(), annot=True, cmap="coolwarm")
    st.pyplot(plt.gcf())

    # Feature Importance (if available)
    if hasattr(model, "feature_importances_"):
        st.subheader("üìå Feature Importance")
        importances = model.feature_importances_
        features = df.drop(columns=["Occupancy", "Date"], errors='ignore').columns[:len(importances)]
        fig_imp = px.bar(x=features, y=importances, title="Feature Importance")
        st.plotly_chart(fig_imp)

    # Prediction
    st.subheader("üì¶ Batch Prediction")
    input_df = df.drop(columns=["Occupancy", "Date"], errors='ignore')
    predictions = model.predict(input_df)
    df["Predicted Occupancy"] = predictions
    st.dataframe(df)
    st.download_button("üì• Download Results", df.to_csv(index=False), file_name="predictions.csv")

    # Evaluation Metrics (if ground truth exists)
    if "Occupancy" in df.columns:
        y_true = df["Occupancy"]
        y_pred = df["Predicted Occupancy"]

        st.subheader("‚úÖ Model Performance")
        col1, col2, col3 = st.columns(3)
        col1.metric("Accuracy", f"{accuracy_score(y_true, y_pred):.2f}")
        col2.metric("Precision", f"{precision_score(y_true, y_pred):.2f}")
        col3.metric("Recall", f"{recall_score(y_true, y_pred):.2f}")

        # Confusion Matrix
        st.subheader("üìâ Confusion Matrix")
        cm = confusion_matrix(y_true, y_pred)
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
        st.pyplot(plt.gcf())

        # ROC Curve
        st.subheader("üìà ROC Curve")
        if hasattr(model, "predict_proba"):
            y_proba = model.predict_proba(input_df)[:, 1]
            fpr, tpr, _ = roc_curve(y_true, y_proba)
            plt.figure()
            plt.plot(fpr, tpr, label=f'AUC = {auc(fpr, tpr):.2f}')
            plt.plot([0,1], [0,1], linestyle='--')
            plt.xlabel("False Positive Rate")
            plt.ylabel("True Positive Rate")
            plt.legend()
            st.pyplot(plt.gcf())

# Single Prediction
st.sidebar.subheader("üìç Single Prediction")
temp = st.sidebar.number_input("Temperature")
#humidity = st.sidebar.number_input("Humidity")
light = st.sidebar.number_input("Light")
co2 = st.sidebar.number_input("CO2")
humidity_ratio = st.sidebar.number_input("Humidity Ratio")

if st.sidebar.button("Predict"):
    single_input = pd.DataFrame([[temp, light, co2, humidity_ratio]],
                                columns=["Temperature", "Light", "CO2", "HumidityRatio"])
    pred = model.predict(single_input)[0]
    st.sidebar.success(f"Predicted Occupancy: {'Yes' if pred == 1 else 'No'}")

# Footer
st.markdown("---")
st.markdown("Developed by Aydan | Occupancy Detection App")